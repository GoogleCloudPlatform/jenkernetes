package org.jenkinsci.plugins.kubernetesworkflowsteps;

import com.google.common.net.HttpHeaders;

import groovy.json.JsonBuilder;
import groovy.json.JsonSlurper;

import org.apache.http.HttpHost;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpDelete;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.client.methods.HttpRequestBase;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLContextBuilder;
import org.apache.http.conn.ssl.SSLContexts;
import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicHeader;

import hudson.EnvVars;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;

import javax.net.ssl.SSLContext;

/**
 * TODO: Insert description here. (generated by elibixby)
 */
public class KubernetesClient {

  private static final Map<String,String> env = EnvVars.masterEnvVars;

  private static CloseableHttpClient rwClient = null;
  private static final Object RW_CLIENT_LOCK = new Object();

  private static final CloseableHttpClient roClient = HttpClients.custom()
      .setDefaultHeaders(Collections.singletonList(
          new BasicHeader(HttpHeaders.CONTENT_TYPE, "application/json"))
          ).build();

  private static final HttpHost RW_HOST = new HttpHost(env.get("KUBERNETES_SERVICE_HOST"),
      Integer.valueOf(env.get("KUBERNETES_SERVICE_PORT")), "https");

  private static final HttpHost RO_HOST = new HttpHost(env.get("KUBERNETES_RO_SERVICE_HOST"),
      Integer.valueOf(env.get("KUBERNETES_RO_SERVICE_PORT")), "http");

  //version string
  private static final String prefix = "/api/v1beta2/";

  private static Object parse(CloseableHttpResponse resp) throws IOException{
    try{
      return (new JsonSlurper()).parse((new InputStreamReader(resp.getEntity().getContent())));
    } finally{
      resp.close();
    }
  }

  private static StringEntity toEntity(Object payload) throws UnsupportedEncodingException{
    return new StringEntity(new JsonBuilder(payload).toString());
  }

  private static CloseableHttpClient getRWClient() 
      throws NoSuchAlgorithmException, KeyStoreException, KeyManagementException{
    if(rwClient == null){
      synchronized(RW_CLIENT_LOCK){
        if(rwClient==null){
          SSLContextBuilder builder = SSLContexts.custom();
          builder.loadTrustMaterial(null, new TrustSelfSignedStrategy());

          SSLContext sslContext = builder.build();

          SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslContext,
              SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

          Collection<BasicHeader> headers = new ArrayList<BasicHeader>();
          headers.add(new BasicHeader(HttpHeaders.CONTENT_TYPE, "application/json"));
          headers.add(new BasicHeader(HttpHeaders.AUTHORIZATION, "Bearer " + env.get("BEARER_TOKEN")));

          rwClient = HttpClients.custom()
              .setDefaultHeaders(headers)
              .setSSLSocketFactory(sslsf).build();
        }
      }
    }
    return rwClient;
  }

  private static <T extends HttpRequestBase> CloseableHttpResponse makeRWCall(T request) 
      throws ClientProtocolException, IOException, KeyManagementException,
      NoSuchAlgorithmException, KeyStoreException {
    return getRWClient().execute(RW_HOST, request);
  }

  private static CloseableHttpResponse makeROCall(HttpGet request) 
      throws ClientProtocolException, IOException {  
    return roClient.execute(RO_HOST, request);
  }


  public static Object get(String path) 
      throws ClientProtocolException, 
      IOException {
    return parse(makeROCall(new HttpGet(prefix.concat(path))));
  }

  public static Object delete(String path) 
      throws KeyManagementException,
      ClientProtocolException,
      NoSuchAlgorithmException,
      KeyStoreException, 
      IOException{  
    return parse(makeRWCall(new HttpDelete(prefix.concat(path))));
  }

  public static Object create(String path, Object payload) 
      throws KeyManagementException,
      ClientProtocolException,
      NoSuchAlgorithmException,
      KeyStoreException, 
      IOException{
    HttpPost post = new HttpPost(prefix.concat(path));
    post.setEntity(toEntity(payload));    
    return parse(makeRWCall(post));
  }

  public static Object update(String path, Object payload) 
      throws KeyManagementException,
      ClientProtocolException,
      NoSuchAlgorithmException,
      KeyStoreException, 
      IOException{

    HttpPut put = new HttpPut(prefix.concat(path));
    put.setEntity(toEntity(payload));
    return parse(makeRWCall(put));
  }


}
